// Copyright Â© 2017 NAME HERE <EMAIL ADDRESS>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package server

import (
	"bufio"
	"fmt"
	"html/template"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"runtime"
	"sync"
	"time"

	"github.com/fredericlemoine/gotree/support"
	"github.com/fredericlemoine/gotree/tree"
	"github.com/fredericlemoine/booster-web/io"
	"github.com/fredericlemoine/booster-web/static"
	"github.com/fredericlemoine/booster-web/templates"
	"github.com/nu7hatch/gouuid"
	"github.com/russross/blackfriday"
)

var templatePath string

var templatesMap map[string]*template.Template

// For read / Write to allanalyses map
var lock = sync.RWMutex{}

const (
	STATUS_NOT_EXISTS = -1
	STATUS_PENDING    = 0
	STATUS_RUNNING    = 1
	STATUS_FINISHED   = 2
	STATUS_ERROR      = 3
	STATUS_CANCELED   = 4
	STATUS_TIMEOUT    = 5
)

type Analysis struct {
	Id           string         `json:"id"`           // sha256 sum of reftree and boottree files
	refreader    *bufio.Reader  `json:"-"`            // reftree reader
	bootreader   *bufio.Reader  `json:"-"`            // bootstrap trees reader
	reffile      multipart.File `json:"-"`            // reftree original file (to be able to close it)
	bootfile     multipart.File `json:"-"`            // bootstrap original file (to be able to close it)
	result       *tree.Tree     `json:"-"`            // resulting tree with supports
	Status       int            `json:"status"`       // status code of the analysis
	StatusStr    string         `json:"statusstr"`    // status of the analysis (string)
	Message      string         `json:"message"`      // error message if any
	Nboot        int            `json:"nboot"`        // number of trees that have been processed
	Newick       string         `json:"newick"`       // Newick representation of resulting tree
	Collapsed    string         `json:"collapsed"`    // Newick representation of collapsed resulting tree
	StartPending string         `json:startpending`   // Analysis queue time
	StartRunning string         `json:"startrunning"` // Analysis Start running time
	End          string         `json:"end"`          // Analysis End time
}

var queue chan *Analysis // queue of analyses
var uuids chan string    // channel of uuids generated by a go routine

var allanalyses map[string]*Analysis // map between sha256 ids and analyses

func InitServer(queuesize, nbrunner, timeout int) {
	initUUIDGenerator()
	initRunners(queuesize, nbrunner, timeout)
	//initCleanKill()

	templatePath = "webapp" + string(os.PathSeparator) + "templates" + string(os.PathSeparator)

	formtpl, err1 := templates.Asset(templatePath + "inputform.html")
	if err1 != nil {
		log.Fatal(err1)
	}
	errtpl, err2 := templates.Asset(templatePath + "error.html")
	if err2 != nil {
		log.Fatal(err2)
	}
	viewtpl, err3 := templates.Asset(templatePath + "view.html")
	if err3 != nil {
		log.Fatal(err3)
	}
	indextpl, err4 := templates.Asset(templatePath + "index.html")
	if err4 != nil {
		log.Fatal(err4)
	}
	layouttpl, err5 := templates.Asset(templatePath + "layout.html")
	if err5 != nil {
		log.Fatal(err5)
	}
	helptpl, err6 := templates.Asset(templatePath + "help.html")
	if err6 != nil {
		log.Fatal(err6)
	}

	templatesMap = make(map[string]*template.Template)

	if t, err := template.New("inputform").Parse(string(layouttpl) + string(formtpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["inputform"] = t
	}

	if t, err := template.New("error").Parse(string(layouttpl) + string(errtpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["error"] = t
	}

	if t, err := template.New("view").Parse(string(layouttpl) + string(viewtpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["view"] = t
	}

	if t, err := template.New("index").Parse(string(layouttpl) + string(indextpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["index"] = t
	}

	if t, err := template.New("help").Funcs(template.FuncMap{"markDown": markDowner}).Parse(string(layouttpl) + string(helptpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["help"] = t
	}

	/* HTML handlers */
	http.HandleFunc("/new/", newHandler)                /* Handler for input form */
	http.HandleFunc("/run", runHandler)                 /* Handler for running a new analysis */
	http.HandleFunc("/help", helpHandler)               /* Handler for the help page */
	http.HandleFunc("/view/", makeHandler(viewHandler)) /* Handler for viewing analysis results */
	http.HandleFunc("/itol/", makeHandler(itolHandler)) /* Handler for uploading tree to itol */
	http.HandleFunc("/", indexHandler)                  /* Home Page*/

	/* Api handlers */
	http.HandleFunc("/api/analysis/", makeApiHandler(apiAnalysisHandler)) /* Handler for returning an analysis */

	/* Static files handlers : js, css, etc. */
	http.Handle("/static/", http.FileServer(static.AssetFS()))
	//http.Handle("/", http.RedirectHandler("/new/", http.StatusFound))

	http.ListenAndServe(":8080", nil)
}

func initRunners(queuesize, nbrunner, timeout int) {
	var maxcpus int = runtime.NumCPU() // max number of cpus

	if nbrunner > (maxcpus - 1) {
		nbrunner = maxcpus - 1
	}
	if nbrunner <= 0 {
		log.Fatal("Your system does not have enough cpus to run the http server + bootstrap runners (at least 2 processors)")
	}

	if queuesize <= 0 {
		log.Fatal("The queue size must be set to a value >0")
	}
	if queuesize < 100 {
		log.Print("The queue size is <100, it may be a problem for users")
	}

	queue = make(chan *Analysis, queuesize)
	allanalyses = make(map[string]*Analysis)

	// We initialize computing routines
	for cpu := 0; cpu < nbrunner; cpu++ {
		go func(cpu int) {
			for a := range queue {
				log.Print(fmt.Sprintf("CPU=%d | New analysis, id=%s", cpu, a.Id))

				a.Status = STATUS_RUNNING
				a.StartRunning = time.Now().Format(time.RFC1123)
				a.StatusStr = StatusStr(a.Status)
				supporter := &support.MastSupporter{}
				finished := false
				var wg sync.WaitGroup // For waiting end of step computation
				wg.Add(1)
				go func() {
					t, err := support.ComputeSupportFile(a.refreader, a.bootreader, os.Stderr, false, 1, supporter)
					a.End = time.Now().Format(time.RFC1123)

					if err != nil {
						io.LogError(err)
						a.Message = err.Error()
						a.Status = STATUS_ERROR
						a.StatusStr = StatusStr(a.Status)
					} else {
						if supporter.Canceled() {
							a.Status = STATUS_TIMEOUT
							a.StatusStr = StatusStr(a.Status)
						} else {
							a.Status = STATUS_FINISHED
							a.StatusStr = StatusStr(a.Status)
						}
						t.ClearPvalues()
						a.result = t
						a.Newick = t.Newick()
						a.Collapsed = a.Newick
						a.Message = "Finished"
					}
					a.reffile.Close()
					a.bootfile.Close()
					wg.Done()
				}()

				go func() {
					for {
						a.Nboot = supporter.Progress()
						if finished {
							break
						}
						time.Sleep(1 * time.Second)
					}
				}()

				go func() {
					time.Sleep(time.Duration(timeout) * time.Second)
					if !finished {
						supporter.Cancel()
					}
				}()
				wg.Wait()
				a.Nboot = supporter.Progress()
				finished = true
			}
			log.Print(fmt.Sprintf("CPU %d : End", cpu))
		}(cpu)
	}
}

func initUUIDGenerator() {
	uuids = make(chan string, 100)
	// The uuid generator will put uuids in the channel
	// When a new analysis is launched, one uuid will be taken
	// from the channel
	go func() {
		for {
			u, err := uuid.NewV4()
			if err != nil {
				log.Print(err)
			} else {
				uuids <- u.String()
			}
		}
	}()
}

// func initCleanKill() {
// 	go func() {
// 		c := make(chan os.Signal, 1)
// 		for {
// 			s := <-c
// 			if s == signal.Kill {
// 				close(queue)
// 				break
// 			}
// 		}
// 	}()
// }

func newAnalysis(refreader, bootreader *bufio.Reader, reffile, bootfile multipart.File) (a *Analysis) {
	lock.Lock()
	defer lock.Unlock()

	a = &Analysis{
		<-uuids,
		refreader,
		bootreader,
		reffile,
		bootfile,
		nil,
		STATUS_PENDING,
		StatusStr(STATUS_PENDING),
		"",
		0,
		"",
		"",
		time.Now().Format(time.RFC1123),
		"",
		"",
	}

	log.Print(fmt.Sprintf("New analysis submited | id=%s | Queue length is %d: ", a.Id, len(queue)))

	allanalyses[a.Id] = a

	select {
	case queue <- a: // Put a in the channel unless it is full
	default:
		//Channel full. Discarding value
		a.Status = STATUS_CANCELED
		a.StatusStr = StatusStr(a.Status)
		a.End = time.Now().Format(time.RFC1123)
		a.Message = "Computing queue is full, please try again in a few minutes"
		a.reffile.Close()
		a.bootfile.Close()
	}
	return
}

func getAnalysis(id string) (a *Analysis, ok bool) {
	lock.RLock()
	defer lock.RUnlock()

	a, ok = allanalyses[id]
	return
}

func StatusStr(status int) string {
	switch status {
	case STATUS_NOT_EXISTS:
		return "Analysis does not exist"
	case STATUS_PENDING:
		return "Pending"
	case STATUS_RUNNING:
		return "Running"
	case STATUS_FINISHED:
		return "Finished"
	case STATUS_ERROR:
		return "Error"
	case STATUS_CANCELED:
		return "Canceled"
	case STATUS_TIMEOUT:
		return "Timeout"
	default:
		return "Unknown"
	}
}

func markDowner(args ...interface{}) template.HTML {
	s := blackfriday.MarkdownCommon([]byte(fmt.Sprintf("%s", args...)))
	return template.HTML(s)
}
