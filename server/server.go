// Copyright Â© 2017 NAME HERE <EMAIL ADDRESS>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package server

import (
	"bufio"
	"fmt"
	"html/template"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"runtime"
	"sync"

	"github.com/fredericlemoine/gotree/support"
	"github.com/fredericlemoine/gotree/tree"
	"github.com/fredericlemoine/sbsweb/io"
	"github.com/nu7hatch/gouuid"
)

var templatePath string

var templates *template.Template

// For read / Write to allanalyses map
var lock = sync.RWMutex{}

const (
	STATUS_PENDING  = 0
	STATUS_RUNNING  = 1
	STATUS_FINISHED = 2
	STATUS_ERROR    = 3
	STATUS_CANCELED = 4
	STATUS_TIMEOUT  = 5
)

type Analysis struct {
	Id         string         // sha256 sum of reftree and boottree files
	refreader  *bufio.Reader  // reftree reader
	bootreader *bufio.Reader  // bootstrap trees reader
	reffile    multipart.File // reftree original file (to be able to close it)
	bootfile   multipart.File // bootstrap original file (to be able to close it)
	result     *tree.Tree     // resulting tree with supports
	Status     int            // status of the analysis
	Message    string         // error message if any
}

var queue chan *Analysis // queue of analyses
var uuids chan string    // channel of uuids generated by a go routine

var allanalyses map[string]*Analysis // map between sha256 ids and analyses

func InitServer(queuesize, nbrunner int) {
	initUUIDGenerator()
	initRunners(queuesize, nbrunner)
	//initCleanKill()

	templatePath = "webapp" + string(os.PathSeparator) + "templates" + string(os.PathSeparator)

	formtpl, err := Asset(templatePath + "inputform.html")
	if err != nil {
		log.Fatal(err)
	}
	errtpl, err2 := Asset(templatePath + "error.html")
	if err2 != nil {
		log.Fatal(err2)
	}

	viewtpl, err3 := Asset(templatePath + "view.html")
	if err3 != nil {
		log.Fatal(err3)
	}

	if templates, err = template.New("inputform.html").Parse(string(formtpl)); err != nil {
		log.Fatal(err)
	}
	if templates, err = templates.New("error.html").Parse(string(errtpl)); err != nil {
		log.Fatal(err)
	}
	if templates, err = templates.New("view.html").Parse(string(viewtpl)); err != nil {
		log.Fatal(err)
	}

	/* HTML handlers */
	http.HandleFunc("/new/", newHandler)                /* Handler for input form */
	http.HandleFunc("/run", runHandler)                 /* Handler for running a new analysis */
	http.HandleFunc("/view/", makeHandler(viewHandler)) /* Handler for viewing analysis results */
	http.HandleFunc("/itol/", makeHandler(itolHandler)) /* Handler for uploading tree to itol */

	/* Static files handlers : js, css, etc. */
	http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(assetFS())))
	http.Handle("/", http.RedirectHandler("/new/", http.StatusFound))

	http.ListenAndServe(":8080", nil)
}

func initRunners(queuesize, nbrunner int) {
	var maxcpus int = runtime.NumCPU() // max number of cpus

	if nbrunner > (maxcpus - 1) {
		nbrunner = maxcpus - 1
	}
	if nbrunner <= 0 {
		log.Fatal("Your system does not have enough cpus to run the http server + bootstrap runners (at least 2 processors)")
	}

	if queuesize <= 0 {
		log.Fatal("The queue size must be set to a value >0")
	}
	if queuesize < 100 {
		log.Print("The queue size is <100, it may be a problem for users")
	}

	queue = make(chan *Analysis, queuesize)
	allanalyses = make(map[string]*Analysis)

	// We initialize computing routines
	for cpu := 0; cpu < nbrunner; cpu++ {
		go func(cpu int) {
			for a := range queue {
				log.Print(fmt.Sprintf("CPU=%d | New analysis, id=%s", cpu, a.Id))

				a.Status = STATUS_RUNNING
				t, err := support.MastLikeFile(a.refreader, a.bootreader, os.Stderr, false, 1)
				if err != nil {
					io.LogError(err)
					a.Message = err.Error()
					a.Status = STATUS_ERROR
				} else {
					t.ClearPvalues()
					a.result = t
					a.Status = STATUS_FINISHED
					a.Message = t.Newick()
				}
				a.reffile.Close()
				a.bootfile.Close()
			}
			log.Print(fmt.Sprintf("CPU %d : End", cpu))
		}(cpu)
	}
}

func initUUIDGenerator() {
	uuids = make(chan string, 100)
	// The uuid generator will put uuids in the channel
	// When a new analysis is launched, one uuid will be taken
	// in the channel
	go func() {
		for {
			u, err := uuid.NewV4()
			if err != nil {
				log.Print(err)
			} else {
				uuids <- u.String()
			}
		}
	}()
}

// func initCleanKill() {
// 	go func() {
// 		c := make(chan os.Signal, 1)
// 		for {
// 			s := <-c
// 			if s == signal.Kill {
// 				close(queue)
// 				break
// 			}
// 		}
// 	}()
// }

func newAnalysis(refreader, bootreader *bufio.Reader, reffile, bootfile multipart.File) (a *Analysis) {
	lock.Lock()
	defer lock.Unlock()

	a = &Analysis{
		<-uuids,
		refreader,
		bootreader,
		reffile,
		bootfile,
		nil,
		STATUS_PENDING,
		"",
	}

	log.Print(fmt.Sprintf("New analysis submited | id=%s | Queue length is %d: ", a.Id, len(queue)))

	allanalyses[a.Id] = a

	select {
	case queue <- a: // Put a in the channel unless it is full
	default:
		//Channel full. Discarding value
		a.Status = STATUS_CANCELED
		a.Message = "Computing queue is full, please try again in a few minutes"
		a.reffile.Close()
		a.bootfile.Close()
	}
	return
}

func getAnalysis(id string) (a *Analysis, ok bool) {
	lock.RLock()
	defer lock.RUnlock()

	a, ok = allanalyses[id]
	return
}
