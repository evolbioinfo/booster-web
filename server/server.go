/*

BOOSTER-WEB: Web interface to BOOSTER (https://github.com/evolbioinfo/booster)
Alternative method to compute bootstrap branch supports in large trees.

Copyright (C) 2017 BOOSTER-WEB dev team

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

package server

import (
	"bufio"
	"compress/gzip"
	"errors"
	"fmt"
	"html/template"
	goio "io"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"
	"time"

	uuid "github.com/nu7hatch/gouuid"
	"github.com/russross/blackfriday"

	"github.com/evolbioinfo/booster-web/config"
	"github.com/evolbioinfo/booster-web/database"
	"github.com/evolbioinfo/booster-web/model"
	"github.com/evolbioinfo/booster-web/notification"
	"github.com/evolbioinfo/booster-web/processor"
	"github.com/evolbioinfo/booster-web/static"
	"github.com/evolbioinfo/booster-web/templates"
	"github.com/evolbioinfo/goalign/align"
	"github.com/evolbioinfo/goalign/io/fasta"
	"github.com/evolbioinfo/goalign/io/phylip"
	"github.com/evolbioinfo/goalign/io/utils"
	"github.com/evolbioinfo/gotree/io/newick"
	tutils "github.com/evolbioinfo/gotree/io/utils"
	"github.com/evolbioinfo/gotree/tree"
)

const (
	DATABASE_TYPE_DEFAULT = "memory"
	HTTP_PORT_DEFAULT     = 8080 // Port 8080
)

var templatePath string

var templatesMap map[string]*template.Template

var db database.BoosterwebDB

var proc processor.Processor

var uuids chan string // channel of uuids generated by a go routine

var logfile *os.File = nil

var emailNotifier notification.Notifier

var galaxyprocessor bool // if the processor is a galaxyprocessor
var emailnotification bool

// The config should contain following keys:
// runners.queuesize: Max number of jobs in the queue (default 10)
// runners.nbrunners: Max number of parallel running jobs (default 1)
// runners.timeout for each running job in Seconds (default 0=unlimited)
// runners.jobthreads : Number of cpus per bootstrap runner
// database.type: mysql or memory (default memory)
// database.user: user to connect to mysql if type is mysql
// database.host: host to connect to mysql if type is mysql
// database.port: port to connect to mysql if type is mysql
// database.pass: pass to connect to mysql if type is mysql
// database.dbname: name of db to connect to mysql if type is mysql
// logging.logfile : path to log file: stdout, stderr or any file name (default stderr)
func InitServer(cfg config.Provider) {
	initLog(cfg)

	log.Print("Starting booster-web")

	templatePath = "webapp" + string(os.PathSeparator) + "templates" + string(os.PathSeparator)

	formtpl, err1 := templates.Asset(templatePath + "inputform.html")
	if err1 != nil {
		log.Fatal(err1)
	}
	errtpl, err2 := templates.Asset(templatePath + "error.html")
	if err2 != nil {
		log.Fatal(err2)
	}
	viewtpl, err3 := templates.Asset(templatePath + "view.html")
	if err3 != nil {
		log.Fatal(err3)
	}
	indextpl, err4 := templates.Asset(templatePath + "index.html")
	if err4 != nil {
		log.Fatal(err4)
	}
	layouttpl, err5 := templates.Asset(templatePath + "layout.html")
	if err5 != nil {
		log.Fatal(err5)
	}
	helptpl, err6 := templates.Asset(templatePath + "help.html")
	if err6 != nil {
		log.Fatal(err6)
	}
	logintpl, err7 := templates.Asset(templatePath + "login.html")
	if err7 != nil {
		log.Fatal(err7)
	}
	maintenancetpl, err8 := templates.Asset(templatePath + "maintenance.html")
	if err8 != nil {
		log.Fatal(err8)
	}

	templatesMap = make(map[string]*template.Template)

	if t, err := template.New("inputform").Parse(string(layouttpl) + string(formtpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["inputform"] = t
	}

	if t, err := template.New("error").Parse(string(layouttpl) + string(errtpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["error"] = t
	}

	if t, err := template.New("view").Parse(string(layouttpl) + string(viewtpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["view"] = t
	}

	if t, err := template.New("index").Parse(string(layouttpl) + string(indextpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["index"] = t
	}

	if t, err := template.New("help").Funcs(template.FuncMap{"markDown": markDowner}).Parse(string(layouttpl) + string(helptpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["help"] = t
	}

	if t, err := template.New("login").Parse(string(layouttpl) + string(logintpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["login"] = t
	}

	if t, err := template.New("maintenance").Parse(string(layouttpl) + string(maintenancetpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["maintenance"] = t
	}

	/* Static files handlers : js, css, etc. */
	http.Handle("/static/", http.FileServer(static.AssetFS()))
	//http.Handle("/", http.RedirectHandler("/new/", http.StatusFound))

	if cfg.GetBool("general.maintenance") {
		http.HandleFunc("/", maintenanceHandler) /* Handler for maintenance page  */
	} else {
		initUUIDGenerator()
		initDB(cfg)
		initEmailNotification(cfg)
		initProcessor(cfg)
		initCleanKill()
		initLogin(cfg)

		/* HTML handlers */
		http.HandleFunc("/new/", validateHtml(newHandler))                       /* Handler for input form */
		http.HandleFunc("/run", validateHtml(runHandler))                        /* Handler for running a new analysis */
		http.HandleFunc("/view/", validateHtml(makeHandler(viewHandler)))        /* Handler for viewing analysis results */
		http.HandleFunc("/itol/", validateHtml(makeRawNormHandler(itolHandler))) /* Handler for uploading tree to itol */
		http.HandleFunc("/help", validateHtml(helpHandler))                      /* Handler for the help page */
		http.HandleFunc("/", validateHtml(indexHandler))                         /* Home Page*/
		http.HandleFunc("/login", loginHandler)                                  /* Handler for login */
		http.HandleFunc("/settoken", setToken)                                   /* Set token in cookie via form post */
		http.HandleFunc("/gettoken", getToken)                                   /* get token via api using json post data */
		http.HandleFunc("/logout", validateHtml(logout))                         /* Handler for logout */

		/* Api handlers */
		http.HandleFunc("/api/analysis/", validateApi(makeApiAnalysisHandler(apiAnalysisHandler))) /* Handler for returning an analysis */
		http.HandleFunc("/api/image/", validateApi(makeApiImageHandler(apiImageHandler)))          /* Handler for returning a tree image */
		http.HandleFunc("/api/randrunname", validateApi(makeApiHandler(apiRandNameGeneratorHandler)))
		http.HandleFunc("/status", validateApi(apiStatus)) /* Handler for getting server status */
	}
	port := cfg.GetInt("http.port")
	if port == 0 {
		port = HTTP_PORT_DEFAULT
	}
	log.Print(fmt.Sprintf("HTTP port: %d", port))
	log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", port), nil))
}

func initProcessor(cfg config.Provider) {
	nbrunners := cfg.GetInt("runners.nbrunners")
	queuesize := cfg.GetInt("runners.queuesize")
	timeout := cfg.GetInt("runners.timeout")
	memlimit := cfg.GetInt("runners.memlimit")
	jobthreads := cfg.GetInt("runners.jobthreads")
	galaxykey := cfg.GetString("galaxy.key")
	galaxyurl := cfg.GetString("galaxy.url")
	proctype := cfg.GetString("runners.type")
	requestattempts := cfg.GetInt("galaxy.requestattempts")
	boosterid := cfg.GetString("galaxy.tools.booster")
	phymlid := cfg.GetString("galaxy.tools.phyml")
	fasttreeid := cfg.GetString("galaxy.tools.fasttree")

	if requestattempts == 0 {
		requestattempts = 1
	}

	galaxyprocessor = false

	switch proctype {
	case "galaxy":
		if galaxyurl == "" {
			log.Fatal("galaxyurl must be provided in configuration file when type=galaxy")
		}
		if galaxykey == "" {
			log.Fatal("galaxykey must be provided in configuration file when type=galaxy")
		}
		if boosterid == "" {
			log.Fatal("booster tool id  must be provided in configuration file when type=galaxy")
		}
		if phymlid == "" {
			log.Fatal("phyml-sms tool id  must be provided in configuration file when type=galaxy")
		}
		if fasttreeid == "" {
			log.Fatal("fasttree tool id  must be provided in configuration file when type=galaxy")
		}
		galproc := &processor.GalaxyProcessor{}
		galaxyprocessor = true
		galproc.InitProcessor(galaxyurl, galaxykey, boosterid, phymlid, fasttreeid, requestattempts, db, emailNotifier, queuesize, timeout, memlimit)
		proc = galproc
	case "local", "":
		// Local or not set
		locproc := &processor.LocalProcessor{}
		locproc.InitProcessor(nbrunners, queuesize, timeout, jobthreads, db, emailNotifier)
		proc = locproc
	default:
		log.Fatal(errors.New("No processor named " + proctype))
	}

}

func initUUIDGenerator() {
	uuids = make(chan string, 100)
	// The uuid generator will put uuids in the channel
	// When a new analysis is launched, one uuid will be taken
	// from the channel
	go func() {
		for {
			u, err := uuid.NewV4()
			if err != nil {
				log.Print(err)
			} else {
				uuids <- u.String()
			}
		}
	}()
}

func initCleanKill() {

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt,
		syscall.SIGHUP,
		syscall.SIGINT,
		syscall.SIGTERM,
		syscall.SIGQUIT)

	go func() {
		for sig := range c {
			log.Print(sig)
			//proc.CancelAnalyses()
			if err := db.Disconnect(); err != nil {
				log.Print(err)
			}
			os.Exit(1)
		}
	}()
}

func initDB(cfg config.Provider) {
	dbtype := cfg.GetString("database.type")
	switch dbtype {
	case "memory":
		db = database.NewMemoryBoosterWebDB()
	case "mysql":
		user := cfg.GetString("database.user")
		host := cfg.GetString("database.host")
		pass := cfg.GetString("database.pass")
		dbname := cfg.GetString("database.dbname")
		port := cfg.GetInt("database.port")
		db = database.NewMySQLBoosterwebDB(user, pass, host, dbname, port)
		if err := db.Connect(); err != nil {
			log.Fatal(err)
		}
	default:
		db = database.NewMemoryBoosterWebDB()
		log.Print("Database type not valid, using default: " + DATABASE_TYPE_DEFAULT)
	}

	if err := db.InitDatabase(); err != nil {
		log.Fatal(err)
	}
	initOldAnalysisCleaner(cfg)
}

func initOldAnalysisCleaner(cfg config.Provider) {
	// Will delete old analyses from database
	// once a day
	agelimit := cfg.GetInt("database.keepold")
	if agelimit > 0 {
		go func() {
			for {
				if err := db.DeleteOldAnalyses(agelimit); err != nil {
					log.Print("Error while deleting old analyses: " + err.Error())
				}
				time.Sleep(24 * time.Hour)
			}
		}()
	}
}

func initLog(cfg config.Provider) {
	logf := cfg.GetString("logging.logfile")
	switch logf {
	case "stderr":
		log.Print("Log file: stderr")
		logfile = os.Stderr
	case "stdout":
		log.Print("Log file: stdout")
		logfile = os.Stdout
	case "":
		log.Print("Log file: stderr")
		logfile = os.Stderr
	default:
		log.Print("Log file: " + logf)
		var err error
		logfile, err = os.OpenFile(logf, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
		if err != nil {
			log.Fatal(err)
		}
	}
	log.SetOutput(logfile)
}

func initLogin(cfg config.Provider) {
	user := cfg.GetString("authentication.user")
	pass := cfg.GetString("authentication.password")
	if user != "" && pass != "" {
		Authent = true
		Username = user
		Password = pass
	}
}

func initEmailNotification(cfg config.Provider) {
	emailnotification = false
	if cfg.GetBool("notification.activated") {
		smtp := cfg.GetString("notification.smtp")
		port := cfg.GetInt("notification.port")
		user := cfg.GetString("notification.user")
		pass := cfg.GetString("notification.pass")
		sender := cfg.GetString("notification.sender")
		resultpage := cfg.GetString("notification.resultpage")
		emailNotifier = notification.NewEmailNotifier(smtp, port, user, pass, sender, resultpage)
		emailnotification = true
	} else {
		emailNotifier = notification.NewNullNotifier()
	}
}

// Creates a new analysis
//
// workflow is sed only if sefseqs is defined : full phylogenetic workflow
func newAnalysis(refalign multipart.File, refalignheader *multipart.FileHeader,
	reffile multipart.File, refheader *multipart.FileHeader,
	bootfile multipart.File, bootheader *multipart.FileHeader,
	email, runname string, nbootrep int, workflow string) (a *model.Analysis, err error) {

	var uuid string
	var dir string
	var seqalignfile, treefile, boottreefile string

	uuid = <-uuids

	a = model.NewAnalysis()
	a.Id = uuid
	a.EMail = email
	a.RunName = runname
	a.NbootRep = nbootrep
	a.Status = model.STATUS_PENDING
	a.Nboot = 0
	a.StartPending = time.Now().Format(time.RFC1123)

	/* tmp analysis folder */
	if dir, err = ioutil.TempDir("", uuid); err != nil {
		log.Printf("Tmp analysis folder error: %v", err)
		return
	}

	// Reference sequences if given
	if refalignheader != nil && refalignheader.Size != 0 {
		// We parse it while detecting automaticall the format
		var r *bufio.Reader
		var al align.Alignment

		if r, err = utils.GetReaderFromReader(utils.GzipExtension(refalignheader.Filename), refalign); err != nil {
			log.Printf("GetReaderFromReader: %v", err)
			log.Print(err)
			return
		}

		if al, _, err = utils.ParseAlignmentAuto(r, false); err != nil {
			log.Printf("ParseAlignmentAuto: %v", err)
			log.Print(err)
			return
		}

		// Write alignment in fasta or in phylip depending on the workflow to launch: phyml or fasttree
		if seqalignfile, err = writeAlign(al, dir, refalignheader, workflow); err != nil {
			log.Print("WriteAlign seq: %v", err)
			log.Print(err)
			return
		}

		a.Alignfile = fasta.WriteAlignment(al)
		a.AlignAlphabet = al.Alphabet()
		a.AlignNbSeq = al.NbSequences()
		a.AlignLength = al.Length()

		// Given workflow to launch does not exist
		if a.Workflow, err = model.WorkflowConst(workflow); err != nil {
			log.Print("WorkflowConst: %v", err)
			log.Print(err)
			return
		}
		log.Print(fmt.Sprintf("New %s (%d boot) + booster analysis submited | id=%s | ", workflow, a.NbootRep, a.Id))

	} else {
		log.Print(fmt.Sprintf("New booster analysis submited | id=%s | ", a.Id))

		if treefile, err = copyTreeFile(dir, reffile, refheader); err != nil {
			err = errors.New("Reference tree : Newick format error (" + err.Error() + ")")
			log.Print(err)
			return nil, err
		}
		if boottreefile, err = copyTreeFile(dir, bootfile, bootheader); err != nil {
			err = errors.New("Bootstrap trees : Newick format error (" + err.Error() + ")")
			log.Print(err)
			return nil, err
		}

		if err = testSameTips(treefile, boottreefile); err != nil {
			log.Print(err)
			err = errors.New("Reference and bootstrap trees do not have the same tip names")
			log.Print(err)
			return nil, err
		}
	}

	a.SeqAlign = seqalignfile
	a.Reffile = treefile
	a.Bootfile = boottreefile
	err = proc.LaunchAnalysis(a)

	return
}

func getAnalysis(id string) (a *model.Analysis, err error) {
	a, err = db.GetAnalysis(id)
	return
}

func markDowner(args ...interface{}) template.HTML {
	s := blackfriday.MarkdownCommon([]byte(fmt.Sprintf("%s", args...)))
	return template.HTML(s)
}

func copyFile(tmpdir string, infile multipart.File, infileheader *multipart.FileHeader) (fpath string, err error) {
	var f *os.File
	if infileheader != nil {
		fpath = filepath.Join(tmpdir, infileheader.Filename)
		if f, err = os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE, 0666); err != nil {
			log.Print(err)
		} else {
			goio.Copy(f, infile)
		}
		defer f.Close()
	} else {
		err = errors.New("File to copy does not exist")
		log.Print(err)
	}
	return
}

/*
Clean tip names (remove spaces before and after tip names) and copy the tree file
returns an error if the tree file is not in newick format
*/
func copyTreeFile(tmpdir string, infile multipart.File, infileheader *multipart.FileHeader) (fpath string, err error) {
	var treereader *bufio.Reader
	var gzreader *gzip.Reader
	var t tree.Trees
	var trees <-chan tree.Trees
	var f *os.File
	if infileheader != nil {
		fname := strings.TrimSuffix(infileheader.Filename, ".gz")
		/* Read trees */
		/* File reader (plain text or gzip) */
		if strings.HasSuffix(infileheader.Filename, ".gz") {
			if gzreader, err = gzip.NewReader(infile); err != nil {
				log.Print(err)
				return
			}
			treereader = bufio.NewReader(gzreader)
		} else {
			treereader = bufio.NewReader(infile)
		}
		trees = tutils.ReadMultiTrees(treereader, tutils.FORMAT_NEWICK)
		/* Open output file */
		fpath = filepath.Join(tmpdir, fname+".gz")
		if f, err = os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE, 0666); err != nil {
			log.Print(err)
			return
		}
		gw := gzip.NewWriter(f)
		for t = range trees {
			if t.Err != nil {
				err = t.Err
				return
			}
			// Clean tip names if needed
			for _, t := range t.Tree.Tips() {
				t.SetName(strings.TrimSpace(t.Name()))
			}
			// Write the to the output file */
			gw.Write([]byte(t.Tree.Newick() + "\n"))
		}
		gw.Close()
		f.Close()
	} else {
		err = errors.New("File to copy does not exist")
		log.Print(err)
	}
	return
}

// Write alignment in fasta or in phylip depending on the workflow to launch: phyml or fasttree
func writeAlign(al align.Alignment, tmpdir string, infileheader *multipart.FileHeader, workflow string) (fpath string, err error) {
	var f *os.File
	var wf int
	if wf, err = model.WorkflowConst(workflow); err != nil {
		log.Print(err)
		return
	}
	if infileheader != nil {
		fname := strings.TrimSuffix(infileheader.Filename, ".gz")
		fpath = filepath.Join(tmpdir, fname)
		if f, err = os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE, 0666); err != nil {
			log.Print(err)
		} else {
			// replace special characters from sequence names
			al.CleanNames(nil)
			if wf == model.WORKFLOW_PHYML_SMS {
				f.WriteString(phylip.WriteAlignment(al, false, false, false))
			} else {
				f.WriteString(fasta.WriteAlignment(al))
			}
		}
		defer f.Close()
	} else {
		err = errors.New("File to copy does not exist")
		log.Print(err)
	}
	return
}

// Parses the two newick files in input and returns an error if the set of
// tips are different between tree in ref and all tres in boot.
//
// ref is considered as a unique tree file
// boot is a multi newick file (bootstrap trees for example)
func testSameTips(ref, boot string) (err error) {
	var treereader *bufio.Reader
	var treefile goio.Closer
	var reftree *tree.Tree
	var boottree tree.Trees
	var trees <-chan tree.Trees

	if treefile, treereader, err = utils.GetReader(ref); err != nil {
		return
	}
	if reftree, err = newick.NewParser(treereader).Parse(); err != nil {
		return
	}
	treefile.Close()

	/* Read bootstrap trees */
	/* File reader (plain text or gzip) */
	if treefile, treereader, err = utils.GetReader(boot); err != nil {
		return
	}
	defer treefile.Close()
	trees = tutils.ReadMultiTrees(treereader, tutils.FORMAT_NEWICK)
	reftree.UpdateTipIndex()
	for boottree = range trees {
		if boottree.Err != nil {
			err = boottree.Err
			return
		}
		boottree.Tree.UpdateTipIndex()
		if err = reftree.CompareTipIndexes(boottree.Tree); err != nil {
			return
		}
	}
	return
}
