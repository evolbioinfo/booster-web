// Copyright Â© 2017 NAME HERE <EMAIL ADDRESS>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package server

import (
	"bufio"
	"fmt"
	"html/template"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"sync"
	"time"

	"github.com/fredericlemoine/booster-web/database"
	"github.com/fredericlemoine/booster-web/io"
	"github.com/fredericlemoine/booster-web/model"
	"github.com/fredericlemoine/booster-web/static"
	"github.com/fredericlemoine/booster-web/templates"
	"github.com/fredericlemoine/gotree/support"
	"github.com/nu7hatch/gouuid"
	"github.com/russross/blackfriday"
)

var templatePath string

var templatesMap map[string]*template.Template

var db database.BoosterwebDB

var queue chan *model.Analysis // queue of analyses
var uuids chan string          // channel of uuids generated by a go routine

func InitServer(queuesize, nbrunner, timeout int) {
	initUUIDGenerator()
	initRunners(queuesize, nbrunner, timeout)
	initCleanKill()
	initDB()

	templatePath = "webapp" + string(os.PathSeparator) + "templates" + string(os.PathSeparator)

	formtpl, err1 := templates.Asset(templatePath + "inputform.html")
	if err1 != nil {
		log.Fatal(err1)
	}
	errtpl, err2 := templates.Asset(templatePath + "error.html")
	if err2 != nil {
		log.Fatal(err2)
	}
	viewtpl, err3 := templates.Asset(templatePath + "view.html")
	if err3 != nil {
		log.Fatal(err3)
	}
	indextpl, err4 := templates.Asset(templatePath + "index.html")
	if err4 != nil {
		log.Fatal(err4)
	}
	layouttpl, err5 := templates.Asset(templatePath + "layout.html")
	if err5 != nil {
		log.Fatal(err5)
	}
	helptpl, err6 := templates.Asset(templatePath + "help.html")
	if err6 != nil {
		log.Fatal(err6)
	}

	templatesMap = make(map[string]*template.Template)

	if t, err := template.New("inputform").Parse(string(layouttpl) + string(formtpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["inputform"] = t
	}

	if t, err := template.New("error").Parse(string(layouttpl) + string(errtpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["error"] = t
	}

	if t, err := template.New("view").Parse(string(layouttpl) + string(viewtpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["view"] = t
	}

	if t, err := template.New("index").Parse(string(layouttpl) + string(indextpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["index"] = t
	}

	if t, err := template.New("help").Funcs(template.FuncMap{"markDown": markDowner}).Parse(string(layouttpl) + string(helptpl)); err != nil {
		log.Fatal(err)
	} else {
		templatesMap["help"] = t
	}

	/* HTML handlers */
	http.HandleFunc("/new/", newHandler)                /* Handler for input form */
	http.HandleFunc("/run", runHandler)                 /* Handler for running a new analysis */
	http.HandleFunc("/help", helpHandler)               /* Handler for the help page */
	http.HandleFunc("/view/", makeHandler(viewHandler)) /* Handler for viewing analysis results */
	http.HandleFunc("/itol/", makeHandler(itolHandler)) /* Handler for uploading tree to itol */
	http.HandleFunc("/", indexHandler)                  /* Home Page*/

	/* Api handlers */
	http.HandleFunc("/api/analysis/", makeApiHandler(apiAnalysisHandler)) /* Handler for returning an analysis */

	/* Static files handlers : js, css, etc. */
	http.Handle("/static/", http.FileServer(static.AssetFS()))
	//http.Handle("/", http.RedirectHandler("/new/", http.StatusFound))

	http.ListenAndServe(":8080", nil)
}

func initRunners(queuesize, nbrunner, timeout int) {
	var maxcpus int = runtime.NumCPU() // max number of cpus

	if nbrunner > (maxcpus - 1) {
		nbrunner = maxcpus - 1
	}
	if nbrunner <= 0 {
		log.Fatal("Your system does not have enough cpus to run the http server + bootstrap runners (at least 2 processors)")
	}

	if queuesize <= 0 {
		log.Fatal("The queue size must be set to a value >0")
	}
	if queuesize < 100 {
		log.Print("The queue size is <100, it may be a problem for users")
	}

	queue = make(chan *model.Analysis, queuesize)

	// We initialize computing routines
	for cpu := 0; cpu < nbrunner; cpu++ {
		go func(cpu int) {
			for a := range queue {
				log.Print(fmt.Sprintf("CPU=%d | New analysis, id=%s", cpu, a.Id))

				a.Status = model.STATUS_RUNNING
				a.StartRunning = time.Now().Format(time.RFC1123)
				a.StatusStr = model.StatusStr(a.Status)
				supporter := &support.BoosterSupporter{}
				finished := false
				db.UpdateAnalysis(a)

				var wg sync.WaitGroup // For waiting end of step computation
				wg.Add(1)
				go func() {
					t, err := support.ComputeSupport(a.Reffile, a.Bootfile, os.Stderr, false, 1, supporter)
					a.End = time.Now().Format(time.RFC1123)

					if err != nil {
						io.LogError(err)
						a.Message = err.Error()
						a.Status = model.STATUS_ERROR
						a.StatusStr = model.StatusStr(a.Status)
					} else {
						if supporter.Canceled() {
							a.Status = model.STATUS_TIMEOUT
							a.StatusStr = model.StatusStr(a.Status)
						} else {
							a.Status = model.STATUS_FINISHED
							a.StatusStr = model.StatusStr(a.Status)
						}
						t.ClearPvalues()
						a.Result = t.Newick()
						a.Collapsed = a.Result
						a.Message = "Finished"
					}
					db.UpdateAnalysis(a)

					wg.Done()
				}()

				go func() {
					for {
						a.Nboot = supporter.Progress()
						db.UpdateAnalysis(a)
						if finished {
							break
						}
						time.Sleep(4 * time.Second)
					}
				}()

				go func() {
					time.Sleep(time.Duration(timeout) * time.Second)
					if !finished {
						supporter.Cancel()
					}
				}()
				wg.Wait()
				a.Nboot = supporter.Progress()
				db.UpdateAnalysis(a)
				finished = true
			}
			log.Print(fmt.Sprintf("CPU %d : End", cpu))
		}(cpu)
	}
}

func initUUIDGenerator() {
	uuids = make(chan string, 100)
	// The uuid generator will put uuids in the channel
	// When a new analysis is launched, one uuid will be taken
	// from the channel
	go func() {
		for {
			u, err := uuid.NewV4()
			if err != nil {
				log.Print(err)
			} else {
				uuids <- u.String()
			}
		}
	}()
}

func initCleanKill() {
	go func() {
		c := make(chan os.Signal, 1)
		for {
			s := <-c
			if s == signal.Kill {
				if err := db.Disconnect(); err != nil {
					log.Fatal(err)
				}
				break
			}
		}
	}()
}

func initDB() {
	db = database.NewMySQLBoosterwebDB("fred", "fred", "localhost", "booster-web")
	if err := db.Connect(); err != nil {
		log.Fatal(err)
	}
}

func newAnalysis(refreader, bootreader *bufio.Reader, reffile, bootfile multipart.File) (a *model.Analysis) {

	/* TODO: Read all from ref reader and bootreader and save them in temp files (gz) */
	uuid := <-uuids
	reffile, bootfile := dumpfiles(refreader, bootreader)
	reffile.Close()
	bootfile.Close()

	a = &model.Analysis{
		uuid,
		reffile,
		bootfile,
		"",
		model.STATUS_PENDING,
		model.StatusStr(model.STATUS_PENDING),
		"",
		0,
		"",
		"",
		time.Now().Format(time.RFC1123),
		"",
	}

	log.Print(fmt.Sprintf("New analysis submited | id=%s | Queue length is %d: ", a.Id, len(queue)))

	/*  Insert analysis */
	err := db.UpdateAnalysis(a)
	if err != nil {
		a.Status = model.STATUS_CANCELED
		a.StatusStr = model.StatusStr(a.Status)
		a.Message = err.Error()
	} else {
		select {
		case queue <- a: // Put a in the channel unless it is full
		default:
			//Channel full. Discarding value
			a.Status = model.STATUS_CANCELED
			a.StatusStr = model.StatusStr(a.Status)
			a.End = time.Now().Format(time.RFC1123)
			a.Message = "Computing queue is full, please try again in a few minutes"
			db.UpdateAnalysis(a)
		}
	}

	return
}

func getAnalysis(id string) (a *model.Analysis, err error) {
	a, err = db.GetAnalysis(id)
	return
}

func markDowner(args ...interface{}) template.HTML {
	s := blackfriday.MarkdownCommon([]byte(fmt.Sprintf("%s", args...)))
	return template.HTML(s)
}
